<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Resizer Tool</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        @import url('../styles.css');

        .resizer-container {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 15px;
            box-shadow: var(--shadow-lg);
            max-width: 800px;
            margin: 0 auto;
        }

        .upload-area {
            border: 2px dashed var(--accent-color);
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 20px;
            background: var(--bg-primary);
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            background: var(--bg-secondary);
            border-color: #22c55e;
        }

        .upload-area i {
            font-size: 3em;
            color: var(--accent-color);
            margin-bottom: 15px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .control-group {
            background: var(--bg-primary);
            padding: 15px;
            border-radius: 10px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }

        input[type="number"], select {
            width: 100%;
            padding: 8px;
            border: 2px solid var(--accent-color);
            border-radius: 5px;
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .preview-area {
            margin: 20px 0;
            text-align: center;
        }

        #preview {
            max-width: 100%;
            max-height: 400px;
            border-radius: 10px;
            display: none;
        }

        .btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-sm);
        }

        .btn.download {
            background: #22c55e;
        }

        .actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .resizer-container {
                margin: 10px;
                padding: 15px;
            }
        }

        .edit-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            overflow-x: auto;
            padding-bottom: 10px;
        }

        .tab-btn {
            padding: 8px 15px;
            background: var(--bg-primary);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-primary);
            transition: all 0.3s;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tab-btn.active {
            background: var(--accent-color);
            color: white;
        }

        .edit-panel {
            display: none;
            background: var(--bg-primary);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .edit-panel.active {
            display: block;
        }

        .filter-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .filter-option {
            text-align: center;
            cursor: pointer;
            padding: 10px;
            border-radius: 6px;
            transition: all 0.3s;
        }

        .filter-option:hover {
            background: var(--bg-secondary);
        }

        .filter-option img {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 6px;
            margin-bottom: 5px;
        }

        .crop-container {
            position: relative;
            max-width: 100%;
            margin: 0 auto;
        }

        #cropArea {
            position: absolute;
            border: 2px solid var(--accent-color);
            background: rgba(255, 255, 255, 0.2);
            cursor: move;
        }

        .text-controls input, .text-controls select {
            margin-bottom: 10px;
        }

        .slider-control {
            width: 100%;
            margin: 10px 0;
        }

        .color-picker {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 50px;
            height: 50px;
            background-color: transparent;
            border: none;
            cursor: pointer;
        }

        .color-picker::-webkit-color-swatch {
            border-radius: 5px;
            border: 2px solid var(--accent-color);
        }

        .crop-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
        }

        .crop-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 15px;
            max-width: 90%;
            max-height: 90vh;
            overflow: hidden;
        }

        .crop-area {
            position: relative;
            overflow: hidden;
            margin: 20px 0;
        }

        .crop-frame {
            position: absolute;
            border: 2px solid var(--accent-color);
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            cursor: move;
        }

        .crop-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            border: 1px solid var(--accent-color);
        }

        .crop-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
        .crop-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .crop-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }

        .crop-controls {
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body class="theme-skyblue">
    <nav class="navbar">
        <div class="nav-brand">
            <a href="index.html" style="text-decoration: none; color: inherit;">
                <i class="fas fa-arrow-left"></i> Back to Tools
            </a>
        </div>
    </nav>

    <div class="container">
        <h1 style="text-align: center; margin: 40px 0;">Image Resizer</h1>
        
        <div class="resizer-container">
            <div class="upload-area" id="uploadArea">
                <i class="fas fa-cloud-upload-alt"></i>
                <h3>Drop your image here or click to upload</h3>
                <p style="color: var(--text-secondary);">Supports: JPG, PNG, GIF</p>
                <input type="file" id="fileInput" accept="image/*" style="display: none">
            </div>

            <div class="edit-tabs">
                <button class="tab-btn active" data-tab="resize">
                    <i class="fas fa-expand"></i> Resize
                </button>
                <button class="tab-btn" data-tab="crop">
                    <i class="fas fa-crop"></i> Crop
                </button>
                <button class="tab-btn" data-tab="filters">
                    <i class="fas fa-magic"></i> Filters
                </button>
                <button class="tab-btn" data-tab="adjust">
                    <i class="fas fa-sliders-h"></i> Adjust
                </button>
                <button class="tab-btn" data-tab="text">
                    <i class="fas fa-font"></i> Add Text
                </button>
                <button class="tab-btn" data-tab="effects">
                    <i class="fas fa-star"></i> Effects
                </button>
            </div>

            <!-- Resize Panel (Existing) -->
            <div class="edit-panel active" id="resize-panel">
                <div class="controls">
                    <div class="control-group">
                        <label>Width (px)</label>
                        <input type="number" id="widthInput" placeholder="Auto">
                    </div>
                    <div class="control-group">
                        <label>Height (px)</label>
                        <input type="number" id="heightInput" placeholder="Auto">
                    </div>
                    <div class="control-group">
                        <label>Maintain Aspect Ratio</label>
                        <select id="aspectRatio">
                            <option value="yes">Yes</option>
                            <option value="no">No</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Quality (%)</label>
                        <input type="number" id="qualityInput" value="90" min="1" max="100">
                    </div>
                </div>
            </div>

            <!-- Crop Panel -->
            <div class="edit-panel" id="crop-panel">
                <div class="control-group">
                    <label>Aspect Ratio</label>
                    <select id="cropRatio">
                        <option value="free">Free</option>
                        <option value="1:1">Square (1:1)</option>
                        <option value="4:3">4:3</option>
                        <option value="16:9">16:9</option>
                    </select>
                </div>
                <div class="actions">
                    <button class="btn" onclick="applyCrop()">Apply Crop</button>
                    <button class="btn" onclick="resetCrop()">Reset</button>
                </div>
            </div>

            <!-- Filters Panel -->
            <div class="edit-panel" id="filters-panel">
                <div class="filter-options">
                    <div class="filter-option" onclick="applyFilter('none')">
                        <img src="" alt="Original" id="original-preview">
                        <span>Original</span>
                    </div>
                    <div class="filter-option" onclick="applyFilter('grayscale')">
                        <img src="" alt="Grayscale" id="grayscale-preview">
                        <span>Grayscale</span>
                    </div>
                    <div class="filter-option" onclick="applyFilter('sepia')">
                        <img src="" alt="Sepia" id="sepia-preview">
                        <span>Sepia</span>
                    </div>
                    <div class="filter-option" onclick="applyFilter('vintage')">
                        <img src="" alt="Vintage" id="vintage-preview">
                        <span>Vintage</span>
                    </div>
                </div>
            </div>

            <!-- Adjust Panel -->
            <div class="edit-panel" id="adjust-panel">
                <div class="control-group">
                    <label>Brightness</label>
                    <input type="range" min="-100" max="100" value="0" class="slider-control" id="brightness">
                </div>
                <div class="control-group">
                    <label>Contrast</label>
                    <input type="range" min="-100" max="100" value="0" class="slider-control" id="contrast">
                </div>
                <div class="control-group">
                    <label>Saturation</label>
                    <input type="range" min="-100" max="100" value="0" class="slider-control" id="saturation">
                </div>
            </div>

            <!-- Text Panel -->
            <div class="edit-panel" id="text-panel">
                <div class="text-controls">
                    <input type="text" placeholder="Enter text" id="textInput">
                    <select id="fontFamily">
                        <option value="Arial">Arial</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                    </select>
                    <input type="number" placeholder="Font size" id="fontSize" value="24">
                    <input type="color" id="textColor" class="color-picker" value="#000000">
                    <button class="btn" onclick="addText()">Add Text</button>
                </div>
            </div>

            <!-- Effects Panel -->
            <div class="edit-panel" id="effects-panel">
                <div class="control-group">
                    <label>Blur</label>
                    <input type="range" min="0" max="10" value="0" class="slider-control" id="blur">
                </div>
                <div class="control-group">
                    <label>Noise</label>
                    <input type="range" min="0" max="50" value="0" class="slider-control" id="noise">
                </div>
                <div class="control-group">
                    <label>Sharpen</label>
                    <input type="range" min="0" max="10" value="0" class="slider-control" id="sharpen">
                </div>
            </div>

            <div class="preview-area">
                <img id="preview" alt="Preview">
            </div>

            <div class="actions">
                <button class="btn" onclick="processImage()">
                    <i class="fas fa-crop"></i> Resize
                </button>
                <button class="btn download" onclick="downloadImage()" id="downloadBtn" style="display: none;">
                    <i class="fas fa-download"></i> Download
                </button>
            </div>
        </div>
    </div>

    <footer style="text-align: center; padding: 20px; color: var(--text-secondary); margin-top: 40px;">
        Made with ❤️ By RANJAN
    </footer>

    <script>
        let originalImage = null;
        let processedImage = null;
        let cropStartX, cropStartY, isCropping = false;
        let cropBox = null;
        let activeText = null;
        let texts = [];

        document.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme') || 'theme-skyblue';
            document.body.className = savedTheme;

            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            uploadArea.addEventListener('click', () => fileInput.click());
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#22c55e';
            });
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.style.borderColor = '';
            });
            uploadArea.addEventListener('drop', handleDrop);
            fileInput.addEventListener('change', handleFileSelect);
        });

        function handleDrop(e) {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                loadImage(file);
            }
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                originalImage = new Image();
                originalImage.onload = () => {
                    document.getElementById('widthInput').value = originalImage.width;
                    document.getElementById('heightInput').value = originalImage.height;
                    document.getElementById('preview').src = e.target.result;
                    document.getElementById('preview').style.display = 'inline-block';
                    document.getElementById('downloadBtn').style.display = 'none';
                    initializeFilterPreviews();
                    initializeCrop();
                    initializeTextDragging();
                    texts = []; // Reset texts array
                };
                originalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function processImage() {
            if (!originalImage) return;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = parseInt(document.getElementById('widthInput').value) || originalImage.width;
            const height = parseInt(document.getElementById('heightInput').value) || originalImage.height;
            const quality = parseInt(document.getElementById('qualityInput').value) / 100;
            const maintainAspect = document.getElementById('aspectRatio').value === 'yes';

            let finalWidth = width;
            let finalHeight = height;

            if (maintainAspect) {
                const ratio = originalImage.width / originalImage.height;
                if (width) {
                    finalHeight = width / ratio;
                } else if (height) {
                    finalWidth = height * ratio;
                }
            }

            canvas.width = finalWidth;
            canvas.height = finalHeight;
            ctx.drawImage(originalImage, 0, 0, finalWidth, finalHeight);

            processedImage = canvas.toDataURL('image/jpeg', quality);
            document.getElementById('preview').src = processedImage;
            document.getElementById('downloadBtn').style.display = 'inline-flex';
        }

        function downloadImage() {
            if (!processedImage) return;
            
            const link = document.createElement('a');
            link.download = 'resized_image.jpg';
            link.href = processedImage;
            link.click();
        }

        document.querySelectorAll('.tab-btn').forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all buttons and panels
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.edit-panel').forEach(panel => panel.classList.remove('active'));
                
                // Add active class to clicked button and corresponding panel
                button.classList.add('active');
                document.getElementById(`${button.dataset.tab}-panel`).classList.add('active');
            });
        });

        // Add new image processing functions
        function applyFilter(type) {
            if (!originalImage) return;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;
            
            // Apply filter
            switch(type) {
                case 'grayscale':
                    ctx.filter = 'grayscale(100%)';
                    break;
                case 'sepia':
                    ctx.filter = 'sepia(100%)';
                    break;
                case 'vintage':
                    ctx.filter = 'contrast(110%) brightness(110%) sepia(30%)';
                    break;
                default:
                    ctx.filter = 'none';
            }
            
            ctx.drawImage(originalImage, 0, 0);
            updatePreview(canvas.toDataURL());
        }

        function addText() {
            if (!originalImage) return;
            
            const text = {
                content: document.getElementById('textInput').value,
                fontSize: parseInt(document.getElementById('fontSize').value),
                fontFamily: document.getElementById('fontFamily').value,
                color: document.getElementById('textColor').value,
                x: 20,
                y: 40
            };
            
            texts.push(text);
            redrawImage();
        }

        // ... Add more image processing functions for other features

        function updatePreview(dataUrl) {
            document.getElementById('preview').src = dataUrl;
            processedImage = dataUrl;
            document.getElementById('downloadBtn').style.display = 'inline-flex';
        }

        // Initialize filter previews
        function initializeFilterPreviews() {
            if (!originalImage) return;
            
            const filters = ['original', 'grayscale', 'sepia', 'vintage'];
            filters.forEach(filter => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 100;
                canvas.height = 100;
                
                switch(filter) {
                    case 'grayscale':
                        ctx.filter = 'grayscale(100%)';
                        break;
                    case 'sepia':
                        ctx.filter = 'sepia(100%)';
                        break;
                    case 'vintage':
                        ctx.filter = 'contrast(110%) brightness(110%) sepia(30%)';
                        break;
                    default:
                        ctx.filter = 'none';
                }
                
                ctx.drawImage(originalImage, 0, 0, 100, 100);
                document.getElementById(`${filter}-preview`).src = canvas.toDataURL();
            });
        }

        // Add new text dragging functionality
        function initializeTextDragging() {
            const preview = document.getElementById('preview');
            preview.addEventListener('mousedown', startDraggingText);
            preview.addEventListener('mousemove', dragText);
            preview.addEventListener('mouseup', stopDraggingText);
        }

        function startDraggingText(e) {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            texts.forEach(text => {
                if (isClickedOnText(x, y, text)) {
                    activeText = text;
                }
            });
        }

        function dragText(e) {
            if (!activeText) return;

            const rect = e.target.getBoundingClientRect();
            activeText.x = e.clientX - rect.left;
            activeText.y = e.clientY - rect.top;
            redrawImage();
        }

        function stopDraggingText() {
            activeText = null;
        }

        function isClickedOnText(x, y, text) {
            const ctx = document.createElement('canvas').getContext('2d');
            ctx.font = `${text.fontSize}px ${text.fontFamily}`;
            const metrics = ctx.measureText(text.content);
            
            return x >= text.x && 
                   x <= text.x + metrics.width && 
                   y >= text.y - text.fontSize && 
                   y <= text.y;
        }

        // Enhanced text adding functionality
        function addText() {
            if (!originalImage) return;
            
            const text = {
                content: document.getElementById('textInput').value,
                fontSize: parseInt(document.getElementById('fontSize').value),
                fontFamily: document.getElementById('fontFamily').value,
                color: document.getElementById('textColor').value,
                x: 20,
                y: 40
            };
            
            texts.push(text);
            redrawImage();
        }

        // Crop functionality
        function initializeCrop() {
            // Create crop overlay
            const overlay = document.createElement('div');
            overlay.className = 'crop-overlay';
            document.body.appendChild(overlay);

            const cropContainer = document.createElement('div');
            cropContainer.className = 'crop-container';
            overlay.appendChild(cropContainer);

            const cropArea = document.createElement('div');
            cropArea.className = 'crop-area';
            cropContainer.appendChild(cropArea);

            const cropFrame = document.createElement('div');
            cropFrame.className = 'crop-frame';
            cropArea.appendChild(cropFrame);

            // Add resize handles
            ['nw', 'ne', 'sw', 'se'].forEach(pos => {
                const handle = document.createElement('div');
                handle.className = `crop-handle ${pos}`;
                cropFrame.appendChild(handle);
            });

            // Add controls
            const controls = document.createElement('div');
            controls.className = 'crop-controls';
            controls.innerHTML = `
                <button class="btn" onclick="applyCrop()">
                    <i class="fas fa-check"></i> Apply
                </button>
                <button class="btn" onclick="cancelCrop()">
                    <i class="fas fa-times"></i> Cancel
                </button>
            `;
            cropContainer.appendChild(controls);

            let isDragging = false;
            let isResizing = false;
            let currentHandle = null;
            let startX, startY, startWidth, startHeight, startLeft, startTop;

            // Show crop interface when crop tab is selected
            document.querySelector('[data-tab="crop"]').addEventListener('click', () => {
                if (!originalImage) return;
                
                overlay.style.display = 'block';
                const img = document.getElementById('preview');
                
                // Set container size based on image
                cropArea.style.width = img.offsetWidth + 'px';
                cropArea.style.height = img.offsetHeight + 'px';
                
                // Clone image into crop area
                const cropImage = img.cloneNode();
                cropImage.style.width = '100%';
                cropImage.style.height = '100%';
                cropArea.insertBefore(cropImage, cropFrame);

                // Initialize crop frame
                const frameSize = Math.min(cropArea.offsetWidth, cropArea.offsetHeight) * 0.8;
                cropFrame.style.width = frameSize + 'px';
                cropFrame.style.height = frameSize + 'px';
                cropFrame.style.left = (cropArea.offsetWidth - frameSize) / 2 + 'px';
                cropFrame.style.top = (cropArea.offsetHeight - frameSize) / 2 + 'px';
            });

            // Handle dragging
            cropFrame.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);

            function startDrag(e) {
                if (e.target.classList.contains('crop-handle')) {
                    isResizing = true;
                    currentHandle = e.target.classList[1];
                } else {
                    isDragging = true;
                }

                startX = e.clientX;
                startY = e.clientY;
                startWidth = cropFrame.offsetWidth;
                startHeight = cropFrame.offsetHeight;
                startLeft = cropFrame.offsetLeft;
                startTop = cropFrame.offsetTop;
                
                e.preventDefault();
            }

            function drag(e) {
                if (!isDragging && !isResizing) return;

                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                if (isDragging) {
                    let newLeft = startLeft + dx;
                    let newTop = startTop + dy;

                    // Constrain to crop area
                    newLeft = Math.max(0, Math.min(newLeft, cropArea.offsetWidth - cropFrame.offsetWidth));
                    newTop = Math.max(0, Math.min(newTop, cropArea.offsetHeight - cropFrame.offsetHeight));

                    cropFrame.style.left = newLeft + 'px';
                    cropFrame.style.top = newTop + 'px';
                }

                if (isResizing) {
                    let newWidth = startWidth;
                    let newHeight = startHeight;
                    let newLeft = startLeft;
                    let newTop = startTop;

                    // Handle resize based on handle position
                    if (currentHandle.includes('e')) newWidth = startWidth + dx;
                    if (currentHandle.includes('w')) {
                        newWidth = startWidth - dx;
                        newLeft = startLeft + dx;
                    }
                    if (currentHandle.includes('s')) newHeight = startHeight + dy;
                    if (currentHandle.includes('n')) {
                        newHeight = startHeight - dy;
                        newTop = startTop + dy;
                    }

                    // Maintain aspect ratio if needed
                    if (cropRatio !== null) {
                        newHeight = newWidth / cropRatio;
                    }

                    // Apply constraints
                    if (newWidth >= 50 && newLeft >= 0 && newLeft + newWidth <= cropArea.offsetWidth) {
                        cropFrame.style.width = newWidth + 'px';
                        cropFrame.style.left = newLeft + 'px';
                    }
                    if (newHeight >= 50 && newTop >= 0 && newTop + newHeight <= cropArea.offsetHeight) {
                        cropFrame.style.height = newHeight + 'px';
                        cropFrame.style.top = newTop + 'px';
                    }
                }
            }

            function endDrag() {
                isDragging = false;
                isResizing = false;
            }
        }

        function applyCrop() {
            const overlay = document.querySelector('.crop-overlay');
            const cropFrame = document.querySelector('.crop-frame');
            const cropArea = document.querySelector('.crop-area');
            
            if (!cropFrame || !originalImage) return;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Calculate crop coordinates relative to original image
            const scaleX = originalImage.width / cropArea.offsetWidth;
            const scaleY = originalImage.height / cropArea.offsetHeight;

            const cropX = cropFrame.offsetLeft * scaleX;
            const cropY = cropFrame.offsetTop * scaleY;
            const cropWidth = cropFrame.offsetWidth * scaleX;
            const cropHeight = cropFrame.offsetHeight * scaleY;

            canvas.width = cropWidth;
            canvas.height = cropHeight;

            ctx.drawImage(originalImage, 
                cropX, cropY, cropWidth, cropHeight,
                0, 0, cropWidth, cropHeight
            );

            updatePreview(canvas.toDataURL());
            overlay.style.display = 'none';
        }

        function cancelCrop() {
            const overlay = document.querySelector('.crop-overlay');
            overlay.style.display = 'none';
        }

        // Add this code inside the existing <script> tag after existing functions

        // Add adjustment sliders functionality
        document.querySelectorAll('#adjust-panel input[type="range"]').forEach(slider => {
            slider.addEventListener('input', applyAdjustments);
        });

        document.querySelectorAll('#effects-panel input[type="range"]').forEach(slider => {
            slider.addEventListener('input', applyEffects);
        });

        function applyAdjustments() {
            if (!originalImage) return;
            
            const brightness = document.getElementById('brightness').value;
            const contrast = document.getElementById('contrast').value;
            const saturation = document.getElementById('saturation').value;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;
            
            ctx.filter = `brightness(${100 + parseInt(brightness)}%) ` +
                        `contrast(${100 + parseInt(contrast)}%) ` +
                        `saturate(${100 + parseInt(saturation)}%)`;
            
            ctx.drawImage(originalImage, 0, 0);
            updatePreview(canvas.toDataURL());
        }

        function applyEffects() {
            if (!originalImage) return;
            
            const blur = document.getElementById('blur').value;
            const noise = document.getElementById('noise').value;
            const sharpen = document.getElementById('sharpen').value;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;
            
            // Apply blur
            ctx.filter = `blur(${blur}px)`;
            ctx.drawImage(originalImage, 0, 0);
            
            // Apply sharpen using convolution
            if (sharpen > 0) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                applySharpen(imageData.data, canvas.width, canvas.height, sharpen);
                ctx.putImageData(imageData, 0, 0);
            }
            
            // Apply noise
            if (noise > 0) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                applyNoise(imageData.data, noise);
                ctx.putImageData(imageData, 0, 0);
            }
            
            updatePreview(canvas.toDataURL());
        }

        function applySharpen(data, width, height, sharpen) {
            const factor = sharpen / 10;
            const kernel = [
                0, -1 * factor, 0,
                -1 * factor, 4 * factor + 1, -1 * factor,
                0, -1 * factor, 0
            ];
            
            const side = Math.round(Math.sqrt(kernel.length));
            const halfSide = Math.floor(side/2);
            
            const pixels = new Uint8ClampedArray(data.length);
            pixels.set(data);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0;
                    for (let cy = 0; cy < side; cy++) {
                        for (let cx = 0; cx < side; cx++) {
                            const scy = y + cy - halfSide;
                            const scx = x + cx - halfSide;
                            if (scy >= 0 && scy < height && scx >= 0 && scx < width) {
                                const srcPos = (scy * width + scx) * 4;
                                const wt = kernel[cy * side + cx];
                                r += data[srcPos] * wt;
                                g += data[srcPos + 1] * wt;
                                b += data[srcPos + 2] * wt;
                            }
                        }
                    }
                    const dstPos = (y * width + x) * 4;
                    pixels[dstPos] = r;
                    pixels[dstPos + 1] = g;
                    pixels[dstPos + 2] = b;
                    pixels[dstPos + 3] = data[dstPos + 3];
                }
            }
            data.set(pixels);
        }

        function applyNoise(data, amount) {
            for (let i = 0; i < data.length; i += 4) {
                const noise = Math.round((Math.random() - 0.5) * amount);
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise));
                data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise));
            }
        }

        // Enhance text dragging
        function initializeTextDragging() {
            const preview = document.getElementById('preview');
            const previewContainer = preview.parentElement;
            
            let isDragging = false;
            let dragTarget = null;
            let startX, startY;
            let originalX, originalY;

            previewContainer.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);

            function startDrag(e) {
                const rect = preview.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                texts.forEach(text => {
                    if (isClickedOnText(x, y, text)) {
                        isDragging = true;
                        dragTarget = text;
                        startX = e.clientX;
                        startY = e.clientY;
                        originalX = text.x;
                        originalY = text.y;
                    }
                });
            }

            function drag(e) {
                if (!isDragging || !dragTarget) return;

                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                dragTarget.x = originalX + dx;
                dragTarget.y = originalY + dy;

                redrawImage();
            }

            function endDrag() {
                isDragging = false;
                dragTarget = null;
            }
        }

        // Enhance crop functionality
        let cropRatio = null;

        document.getElementById('cropRatio').addEventListener('change', function(e) {
            const ratio = e.target.value;
            if (ratio === 'free') {
                cropRatio = null;
            } else {
                const [width, height] = ratio.split(':').map(Number);
                cropRatio = width / height;
            }
        });

        function updateCrop(e) {
            if (!isCropping) return;
            
            const rect = e.target.getBoundingClientRect();
            let currentX = e.clientX - rect.left;
            let currentY = e.clientY - rect.top;
            
            let width = currentX - cropStartX;
            let height = currentY - cropStartY;
            
            if (cropRatio !== null) {
                height = width / cropRatio;
            }
            
            cropBox.style.width = Math.abs(width) + 'px';
            cropBox.style.height = Math.abs(height) + 'px';
            cropBox.style.left = (width < 0 ? currentX : cropStartX) + 'px';
            cropBox.style.top = (height < 0 ? currentY : cropStartY) + 'px';
        }

        // Add reset functionality for adjustments and effects
        document.querySelectorAll('.edit-panel').forEach(panel => {
            const resetBtn = document.createElement('button');
            resetBtn.className = 'btn';
            resetBtn.innerHTML = '<i class="fas fa-undo"></i> Reset';
            resetBtn.onclick = () => {
                panel.querySelectorAll('input[type="range"]').forEach(input => {
                    input.value = input.getAttribute('value');
                });
                if (originalImage) {
                    updatePreview(originalImage.src);
                }
            };
            panel.appendChild(resetBtn);
        });

        // Improved text handling
        function initializeTextDragging() {
            const preview = document.getElementById('preview');
            const previewWrapper = document.createElement('div');
            previewWrapper.style.position = 'relative';
            preview.parentNode.insertBefore(previewWrapper, preview);
            previewWrapper.appendChild(preview);

            let isDragging = false;
            let selectedText = null;
            let offsetX, offsetY;

            // Create text overlay container
            const textOverlay = document.createElement('div');
            textOverlay.id = 'textOverlay';
            textOverlay.style.position = 'absolute';
            textOverlay.style.top = '0';
            textOverlay.style.left = '0';
            textOverlay.style.width = '100%';
            textOverlay.style.height = '100%';
            textOverlay.style.pointerEvents = 'none';
            previewWrapper.appendChild(textOverlay);

            function renderTexts() {
                textOverlay.innerHTML = '';
                texts.forEach((text, index) => {
                    const textElement = document.createElement('div');
                    textElement.className = 'draggable-text';
                    textElement.style.position = 'absolute';
                    textElement.style.left = `${text.x}px`;
                    textElement.style.top = `${text.y}px`;
                    textElement.style.color = text.color;
                    textElement.style.fontSize = `${text.fontSize}px`;
                    textElement.style.fontFamily = text.fontFamily;
                    textElement.style.cursor = 'move';
                    textElement.style.pointerEvents = 'auto';
                    textElement.style.userSelect = 'none';
                    textElement.textContent = text.content;
                    textElement.dataset.index = index;

                    textElement.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        selectedText = text;
                        const rect = textElement.getBoundingClientRect();
                        offsetX = e.clientX - rect.left;
                        offsetY = e.clientY - rect.top;
                        e.stopPropagation();
                    });

                    textOverlay.appendChild(textElement);
                });
            }

            document.addEventListener('mousemove', (e) => {
                if (isDragging && selectedText) {
                    const rect = textOverlay.getBoundingClientRect();
                    const x = e.clientX - rect.left - offsetX;
                    const y = e.clientY - rect.top - offsetY;
                    
                    selectedText.x = Math.max(0, Math.min(x, rect.width - 50));
                    selectedText.y = Math.max(0, Math.min(y, rect.height - 20));
                    
                    renderTexts();
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    selectedText = null;
                    redrawImage();
                }
            });

            // Enhanced text adding
            const addTextBtn = document.querySelector('.text-controls .btn');
            addTextBtn.onclick = () => {
                const text = {
                    content: document.getElementById('textInput').value,
                    fontSize: parseInt(document.getElementById('fontSize').value),
                    fontFamily: document.getElementById('fontFamily').value,
                    color: document.getElementById('textColor').value,
                    x: 20,
                    y: 40
                };
                
                texts.push(text);
                renderTexts();
                redrawImage();
            };
        }

        // Improved crop functionality
        function initializeCrop() {
            const preview = document.getElementById('preview');
            const cropArea = document.createElement('div');
            cropArea.id = 'cropArea';
            cropArea.style.display = 'none';
            preview.parentElement.appendChild(cropArea);

            let isResizing = false;
            let currentHandle = null;

            // Add resize handles
            const handles = ['nw', 'ne', 'sw', 'se'];
            handles.forEach(handle => {
                const handleElement = document.createElement('div');
                handleElement.className = `crop-handle ${handle}`;
                handleElement.style.position = 'absolute';
                handleElement.style.width = '10px';
                handleElement.style.height = '10px';
                handleElement.style.background = 'white';
                handleElement.style.border = '1px solid black';
                cropArea.appendChild(handleElement);
            });

            function updateCropHandles() {
                const rect = cropArea.getBoundingClientRect();
                const handles = cropArea.querySelectorAll('.crop-handle');
                handles.forEach(handle => {
                    if (handle.classList.contains('nw')) {
                        handle.style.left = '-5px';
                        handle.style.top = '-5px';
                    } else if (handle.classList.contains('ne')) {
                        handle.style.right = '-5px';
                        handle.style.top = '-5px';
                    } else if (handle.classList.contains('sw')) {
                        handle.style.left = '-5px';
                        handle.style.bottom = '-5px';
                    } else if (handle.classList.contains('se')) {
                        handle.style.right = '-5px';
                        handle.style.bottom = '-5px';
                    }
                });
            }

            // Enhanced crop area initialization
            function startCrop(e) {
                if (!document.getElementById('crop-panel').classList.contains('active')) return;
                
                const rect = preview.getBoundingClientRect();
                cropStartX = e.clientX - rect.left;
                cropStartY = e.clientY - rect.top;
                
                cropArea.style.left = `${cropStartX}px`;
                cropArea.style.top = `${cropStartY}px`;
                cropArea.style.width = '0';
                cropArea.style.height = '0';
                cropArea.style.display = 'block';
                
                isCropping = true;
            }

            // Add the following CSS to your existing styles
            const style = document.createElement('style');
            style.textContent = `
                #cropArea {
                    position: absolute;
                    border: 2px solid var(--accent-color);
                    background: rgba(255, 255, 255, 0.2);
                    cursor: move;
                }
                .crop-handle {
                    cursor: pointer;
                    z-index: 1000;
                }
                .crop-handle.nw { cursor: nw-resize; }
                .crop-handle.ne { cursor: ne-resize; }
                .crop-handle.sw { cursor: sw-resize; }
                .crop-handle.se { cursor: se-resize; }
            `;
            document.head.appendChild(style);

            preview.addEventListener('mousedown', startCrop);
            document.addEventListener('mousemove', updateCrop);
            document.addEventListener('mouseup', endCrop);

            // Update the updateCrop function
            function updateCrop(e) {
                if (!isCropping) return;
                
                const rect = preview.getBoundingClientRect();
                const currentX = Math.min(Math.max(e.clientX - rect.left, 0), rect.width);
                const currentY = Math.min(Math.max(e.clientY - rect.top, 0), rect.height);
                
                let width = currentX - cropStartX;
                let height = currentY - cropStartY;

                if (cropRatio !== null) {
                    height = width / cropRatio;
                }

                cropArea.style.width = `${Math.abs(width)}px`;
                cropArea.style.height = `${Math.abs(height)}px`;
                cropArea.style.left = `${width < 0 ? currentX : cropStartX}px`;
                cropArea.style.top = `${height < 0 ? currentY : cropStartY}px`;

                updateCropHandles();
            }
        }

        // Improved redrawImage function
        function redrawImage() {
            if (!originalImage) return;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;
            
            // Draw the base image
            ctx.drawImage(originalImage, 0, 0);
            
            // Draw all texts
            texts.forEach(text => {
                ctx.font = `${text.fontSize}px ${text.fontFamily}`;
                ctx.fillStyle = text.color;
                ctx.textBaseline = 'top';
                
                // Calculate position relative to original image size
                const preview = document.getElementById('preview');
                const scaleX = originalImage.width / preview.offsetWidth;
                const scaleY = originalImage.height / preview.offsetHeight;
                
                const x = text.x * scaleX;
                const y = text.y * scaleY;
                
                ctx.fillText(text.content, x, y);
            });
            
            updatePreview(canvas.toDataURL());
        }

        // Add these event listeners to your existing initialization code
        document.addEventListener('DOMContentLoaded', () => {
            // ... existing initialization code ...

            // Add keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (selectedText) {
                        const index = texts.indexOf(selectedText);
                        if (index > -1) {
                            texts.splice(index, 1);
                            renderTexts();
                            redrawImage();
                        }
                    }
                }
            });
        });
    </script>
</body>
</html>
